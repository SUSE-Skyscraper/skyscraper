// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const addPolicy = `-- name: AddPolicy :exec
insert into policies (id, ptype, v0, v1, v2, v3, v4, v5)
values (uuid_generate_v5('6ba7b812-9dad-11d1-80b4-00c04fd430c8',
                         concat($1::text, $2::text, $3::text, $4::text,
                                $5::text, $6::text, $7::text)), $1::text,
        $2::text, $3::text, $4::text, $5::text, $6::text,
        $7::text)
on conflict do nothing
`

type AddPolicyParams struct {
	Ptype string
	V0    string
	V1    string
	V2    string
	V3    string
	V4    string
	V5    string
}

func (q *Queries) AddPolicy(ctx context.Context, arg AddPolicyParams) error {
	_, err := q.db.Exec(ctx, addPolicy,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
		arg.V4,
		arg.V5,
	)
	return err
}

const createCloudTenant = `-- name: CreateCloudTenant :exec

insert into cloud_tenants (cloud, tenant_id, name)
values ($1, $2, $3)
on conflict (cloud, tenant_id) do update set name       = $3,
                                             updated_at = now()
`

type CreateCloudTenantParams struct {
	Cloud    string
	TenantID string
	Name     string
}

//------------------------------------------------------------------------------------------------------------------
// Cloud Tenants
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateCloudTenant(ctx context.Context, arg CreateCloudTenantParams) error {
	_, err := q.db.Exec(ctx, createCloudTenant, arg.Cloud, arg.TenantID, arg.Name)
	return err
}

const createGroup = `-- name: CreateGroup :one
insert into groups (display_name, created_at, updated_at)
values ($1, now(), now())
returning id, display_name, created_at, updated_at
`

func (q *Queries) CreateGroup(ctx context.Context, displayName string) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, displayName)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMembershipForUserAndGroup = `-- name: CreateMembershipForUserAndGroup :exec
insert into group_members (user_id, group_id, created_at, updated_at)
values ($1, $2, now(), now())
on conflict (user_id, group_id) do update set updated_at = now()
`

type CreateMembershipForUserAndGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) CreateMembershipForUserAndGroup(ctx context.Context, arg CreateMembershipForUserAndGroupParams) error {
	_, err := q.db.Exec(ctx, createMembershipForUserAndGroup, arg.UserID, arg.GroupID)
	return err
}

const createOrInsertCloudAccount = `-- name: CreateOrInsertCloudAccount :one
insert into cloud_accounts (cloud, tenant_id, account_id, name, tags_current, tags_desired)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (cloud, tenant_id, account_id)
    DO UPDATE SET name         = $4,
                  tags_current = $5,
                  updated_at   = now()
returning id, cloud, tenant_id, account_id, name, active, tags_current, tags_desired, tags_drift_detected, created_at, updated_at
`

type CreateOrInsertCloudAccountParams struct {
	Cloud       string
	TenantID    string
	AccountID   string
	Name        string
	TagsCurrent pgtype.JSONB
	TagsDesired pgtype.JSONB
}

func (q *Queries) CreateOrInsertCloudAccount(ctx context.Context, arg CreateOrInsertCloudAccountParams) (CloudAccount, error) {
	row := q.db.QueryRow(ctx, createOrInsertCloudAccount,
		arg.Cloud,
		arg.TenantID,
		arg.AccountID,
		arg.Name,
		arg.TagsCurrent,
		arg.TagsDesired,
	)
	var i CloudAccount
	err := row.Scan(
		&i.ID,
		&i.Cloud,
		&i.TenantID,
		&i.AccountID,
		&i.Name,
		&i.Active,
		&i.TagsCurrent,
		&i.TagsDesired,
		&i.TagsDriftDetected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into users (username, name, display_name, emails, active, locale, external_id, created_at, updated_at)
values ($1, $2, $3, $4, $5, $6, $7, now(), now())
returning id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
`

type CreateUserParams struct {
	Username    string
	Name        pgtype.JSONB
	DisplayName sql.NullString
	Emails      pgtype.JSONB
	Active      bool
	Locale      sql.NullString
	ExternalID  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Name,
		arg.DisplayName,
		arg.Emails,
		arg.Active,
		arg.Locale,
		arg.ExternalID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
delete
from groups
where id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGroup, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
delete
from users
where id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const dropMembershipForGroup = `-- name: DropMembershipForGroup :exec
delete
from group_members
where group_id = $1
`

func (q *Queries) DropMembershipForGroup(ctx context.Context, groupID uuid.UUID) error {
	_, err := q.db.Exec(ctx, dropMembershipForGroup, groupID)
	return err
}

const dropMembershipForUserAndGroup = `-- name: DropMembershipForUserAndGroup :exec
delete
from group_members
where user_id = $1
  and group_id = $2
`

type DropMembershipForUserAndGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) DropMembershipForUserAndGroup(ctx context.Context, arg DropMembershipForUserAndGroupParams) error {
	_, err := q.db.Exec(ctx, dropMembershipForUserAndGroup, arg.UserID, arg.GroupID)
	return err
}

const findAPIKey = `-- name: FindAPIKey :one
select id, token, created_at, updated_at
from scim_api_keys
where token = $1
`

func (q *Queries) FindAPIKey(ctx context.Context, token string) (ScimApiKey, error) {
	row := q.db.QueryRow(ctx, findAPIKey, token)
	var i ScimApiKey
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findByUsername = `-- name: FindByUsername :one
select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
where username = $1
`

func (q *Queries) FindByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, findByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCloudAccount = `-- name: FindCloudAccount :one
select id, cloud, tenant_id, account_id, name, active, tags_current, tags_desired, tags_drift_detected, created_at, updated_at
from cloud_accounts
where id = $1
`

func (q *Queries) FindCloudAccount(ctx context.Context, id uuid.UUID) (CloudAccount, error) {
	row := q.db.QueryRow(ctx, findCloudAccount, id)
	var i CloudAccount
	err := row.Scan(
		&i.ID,
		&i.Cloud,
		&i.TenantID,
		&i.AccountID,
		&i.Name,
		&i.Active,
		&i.TagsCurrent,
		&i.TagsDesired,
		&i.TagsDriftDetected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCloudAccountByCloudAndTenant = `-- name: FindCloudAccountByCloudAndTenant :one
select id, cloud, tenant_id, account_id, name, active, tags_current, tags_desired, tags_drift_detected, created_at, updated_at
from cloud_accounts
where cloud = $1
  and tenant_id = $2
  and account_id = $3
`

type FindCloudAccountByCloudAndTenantParams struct {
	Cloud     string
	TenantID  string
	AccountID string
}

func (q *Queries) FindCloudAccountByCloudAndTenant(ctx context.Context, arg FindCloudAccountByCloudAndTenantParams) (CloudAccount, error) {
	row := q.db.QueryRow(ctx, findCloudAccountByCloudAndTenant, arg.Cloud, arg.TenantID, arg.AccountID)
	var i CloudAccount
	err := row.Scan(
		&i.ID,
		&i.Cloud,
		&i.TenantID,
		&i.AccountID,
		&i.Name,
		&i.Active,
		&i.TagsCurrent,
		&i.TagsDesired,
		&i.TagsDriftDetected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCloudTenant = `-- name: GetCloudTenant :one
select id, cloud, tenant_id, name, active, created_at, updated_at
from cloud_tenants
where cloud = $1
  and tenant_id = $2
`

type GetCloudTenantParams struct {
	Cloud    string
	TenantID string
}

func (q *Queries) GetCloudTenant(ctx context.Context, arg GetCloudTenantParams) (CloudTenant, error) {
	row := q.db.QueryRow(ctx, getCloudTenant, arg.Cloud, arg.TenantID)
	var i CloudTenant
	err := row.Scan(
		&i.ID,
		&i.Cloud,
		&i.TenantID,
		&i.Name,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCloudTenants = `-- name: GetCloudTenants :many
select id, cloud, tenant_id, name, active, created_at, updated_at
from cloud_tenants
order by cloud, tenant_id
`

func (q *Queries) GetCloudTenants(ctx context.Context) ([]CloudTenant, error) {
	rows, err := q.db.Query(ctx, getCloudTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloudTenant
	for rows.Next() {
		var i CloudTenant
		if err := rows.Scan(
			&i.ID,
			&i.Cloud,
			&i.TenantID,
			&i.Name,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :one
select id, display_name, created_at, updated_at
from groups
where id = $1
`

func (q *Queries) GetGroup(ctx context.Context, id uuid.UUID) (Group, error) {
	row := q.db.QueryRow(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupCount = `-- name: GetGroupCount :one
select count(*)
from groups
`

func (q *Queries) GetGroupCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getGroupCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGroupMembership = `-- name: GetGroupMembership :many

select group_members.id, group_members.group_id, group_members.user_id, group_members.created_at, group_members.updated_at, users.username as username
from group_members
         left join users on users.id = group_members.user_id
where group_members.group_id = $1
`

type GetGroupMembershipRow struct {
	ID        int32
	GroupID   uuid.UUID
	UserID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Username  sql.NullString
}

//------------------------------------------------------------------------------------------------------------------
// Membership
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetGroupMembership(ctx context.Context, groupID uuid.UUID) ([]GetGroupMembershipRow, error) {
	rows, err := q.db.Query(ctx, getGroupMembership, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMembershipRow
	for rows.Next() {
		var i GetGroupMembershipRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembershipForUser = `-- name: GetGroupMembershipForUser :one
select group_members.id, group_members.group_id, group_members.user_id, group_members.created_at, group_members.updated_at, users.username as username
from group_members
         left join users on users.id = group_members.user_id
where group_members.group_id = $1
  and group_members.user_id = $2
`

type GetGroupMembershipForUserParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

type GetGroupMembershipForUserRow struct {
	ID        int32
	GroupID   uuid.UUID
	UserID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Username  sql.NullString
}

func (q *Queries) GetGroupMembershipForUser(ctx context.Context, arg GetGroupMembershipForUserParams) (GetGroupMembershipForUserRow, error) {
	row := q.db.QueryRow(ctx, getGroupMembershipForUser, arg.GroupID, arg.UserID)
	var i GetGroupMembershipForUserRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
	)
	return i, err
}

const getGroups = `-- name: GetGroups :many

select id, display_name, created_at, updated_at
from groups
order by id
LIMIT $1 OFFSET $2
`

type GetGroupsParams struct {
	Limit  int32
	Offset int32
}

//------------------------------------------------------------------------------------------------------------------
// Groups
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetGroups(ctx context.Context, arg GetGroupsParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicies = `-- name: GetPolicies :many

select id, ptype, v0, v1, v2, v3, v4, v5
from policies
order by id
`

//------------------------------------------------------------------------------------------------------------------
// Policies
//
// 6ba7b812-9dad-11d1-80b4-00c04fd430c8 is NameSpace_OID as specified in rfc4122 (https://tools.ietf.org/html/rfc4122)
// we use uuid v5 so we can calculate the id from a collection of values
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetPolicies(ctx context.Context) ([]Policy, error) {
	rows, err := q.db.Query(ctx, getPolicies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Policy
	for rows.Next() {
		var i Policy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
where id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCount = `-- name: GetUserCount :one
select count(*)
from users
`

func (q *Queries) GetUserCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getUserCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUsers = `-- name: GetUsers :many

select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
order by id
LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32
	Offset int32
}

//------------------------------------------------------------------------------------------------------------------
// Users
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ExternalID,
			&i.Name,
			&i.DisplayName,
			&i.Locale,
			&i.Active,
			&i.Emails,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAPIKey = `-- name: InsertAPIKey :one

insert into scim_api_keys (token, created_at, updated_at)
values ($1, now(), now())
returning id, token, created_at, updated_at
`

//------------------------------------------------------------------------------------------------------------------
// SCIM API Key
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) InsertAPIKey(ctx context.Context, token string) (ScimApiKey, error) {
	row := q.db.QueryRow(ctx, insertAPIKey, token)
	var i ScimApiKey
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const patchGroupDisplayName = `-- name: PatchGroupDisplayName :exec
update groups
set display_name = $2,
    updated_at   = now()
where id = $1
`

type PatchGroupDisplayNameParams struct {
	ID          uuid.UUID
	DisplayName string
}

func (q *Queries) PatchGroupDisplayName(ctx context.Context, arg PatchGroupDisplayNameParams) error {
	_, err := q.db.Exec(ctx, patchGroupDisplayName, arg.ID, arg.DisplayName)
	return err
}

const patchUser = `-- name: PatchUser :exec
update users
set active     = $2,
    updated_at = now()
where id = $1
`

type PatchUserParams struct {
	ID     uuid.UUID
	Active bool
}

func (q *Queries) PatchUser(ctx context.Context, arg PatchUserParams) error {
	_, err := q.db.Exec(ctx, patchUser, arg.ID, arg.Active)
	return err
}

const removePoliciesForGroup = `-- name: RemovePoliciesForGroup :exec
delete
from policies
where ptype = 'g'
  and v1 = $1
`

func (q *Queries) RemovePoliciesForGroup(ctx context.Context, v1 string) error {
	_, err := q.db.Exec(ctx, removePoliciesForGroup, v1)
	return err
}

const removePolicy = `-- name: RemovePolicy :exec
delete
from policies
where id = uuid_generate_v5('6ba7b812-9dad-11d1-80b4-00c04fd430c8',
                            concat($1, $2, $3, $4, $5,
                                   $6, $7))
`

type RemovePolicyParams struct {
	Ptype interface{}
	V0    interface{}
	V1    interface{}
	V2    interface{}
	V3    interface{}
	V4    interface{}
	V5    interface{}
}

func (q *Queries) RemovePolicy(ctx context.Context, arg RemovePolicyParams) error {
	_, err := q.db.Exec(ctx, removePolicy,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
		arg.V4,
		arg.V5,
	)
	return err
}

const searchTag = `-- name: SearchTag :many

select id, cloud, tenant_id, account_id, name, active, tags_current, tags_desired, tags_drift_detected, created_at, updated_at
from cloud_accounts
where cloud = $1
  and tenant_id = $2
  and tags_current ->> $3 = sqcl.arg(tag_value)
`

type SearchTagParams struct {
	Cloud    string
	TenantID string
	TagKey   pgtype.JSONB
}

//------------------------------------------------------------------------------------------------------------------
// Cloud Account Metadata
//------------------------------------------------------------------------------------------------------------------
func (q *Queries) SearchTag(ctx context.Context, arg SearchTagParams) ([]CloudAccount, error) {
	rows, err := q.db.Query(ctx, searchTag, arg.Cloud, arg.TenantID, arg.TagKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloudAccount
	for rows.Next() {
		var i CloudAccount
		if err := rows.Scan(
			&i.ID,
			&i.Cloud,
			&i.TenantID,
			&i.AccountID,
			&i.Name,
			&i.Active,
			&i.TagsCurrent,
			&i.TagsDesired,
			&i.TagsDriftDetected,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncatePolicies = `-- name: TruncatePolicies :exec
truncate policies
`

func (q *Queries) TruncatePolicies(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncatePolicies)
	return err
}

const updateCloudAccount = `-- name: UpdateCloudAccount :exec
update cloud_accounts
set tags_desired = $2,
    updated_at   = now()
where id = $1
`

type UpdateCloudAccountParams struct {
	ID          uuid.UUID
	TagsDesired pgtype.JSONB
}

func (q *Queries) UpdateCloudAccount(ctx context.Context, arg UpdateCloudAccountParams) error {
	_, err := q.db.Exec(ctx, updateCloudAccount, arg.ID, arg.TagsDesired)
	return err
}

const updateCloudAccountTagsDriftDetected = `-- name: UpdateCloudAccountTagsDriftDetected :exec
update cloud_accounts
set tags_drift_detected = $1,
    updated_at          = now()
where cloud = $2
  and tenant_id = $3
  and account_id = $4
`

type UpdateCloudAccountTagsDriftDetectedParams struct {
	TagsDriftDetected bool
	Cloud             string
	TenantID          string
	AccountID         string
}

func (q *Queries) UpdateCloudAccountTagsDriftDetected(ctx context.Context, arg UpdateCloudAccountTagsDriftDetectedParams) error {
	_, err := q.db.Exec(ctx, updateCloudAccountTagsDriftDetected,
		arg.TagsDriftDetected,
		arg.Cloud,
		arg.TenantID,
		arg.AccountID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
update users
set username     =$2,
    name         = $3,
    display_name = $4,
    emails       = $5,
    active       = $6,
    external_id  = $7,
    locale       = $8,
    updated_at   = now()
where id = $1
`

type UpdateUserParams struct {
	ID          uuid.UUID
	Username    string
	Name        pgtype.JSONB
	DisplayName sql.NullString
	Emails      pgtype.JSONB
	Active      bool
	ExternalID  sql.NullString
	Locale      sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Name,
		arg.DisplayName,
		arg.Emails,
		arg.Active,
		arg.ExternalID,
		arg.Locale,
	)
	return err
}
